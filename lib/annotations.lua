---@meta
-- Sleet ORM — Lua Language Server type declarations
-- *** This file is included with the Sleet library, do not modify manually ***

-- ─────────────────────────────────────────────────────────────
-- ColumnDef<T> — column definition object
-- T is the Lua value type (string, integer, number, boolean, table)
-- ─────────────────────────────────────────────────────────────

---@class ColumnDef<T>
---@field _name          string
---@field _type          string
---@field _tableName     string
---@field primaryKey     fun(): ColumnDef<T>
---@field notNull        fun(): ColumnDef<T>
---@field unique         fun(): ColumnDef<T>
---@field default        fun(val: T): ColumnDef<T>
---@field defaultNow     fun(): ColumnDef<T>
---@field autoIncrement  fun(): ColumnDef<T>
---@field references     fun(col: ColumnDef): ColumnDef<T>
---@field comment        fun(text: string): ColumnDef<T>

-- ─────────────────────────────────────────────────────────────
-- SleetTableDef<R> — marker base class for generated XxxTable types.
-- Carries no visible fields; only used to establish the class hierarchy
-- so that generated types.lua can declare precise from() overloads.
-- ─────────────────────────────────────────────────────────────

---@class SleetTableDef<R>

-- ─────────────────────────────────────────────────────────────
-- Query Builders
-- ─────────────────────────────────────────────────────────────

-- SleetPreSelectBuilder — returned by db.select().
--
-- Design note on 'from':
--   A generic 'from: fun(tbl: table): SleetPreSelectBuilder' fallback would
--   cause a union return type when types.lua is present, because `table` is
--   the supertype of every XxxTable — LuaLS matches both the specific overload
--   (UsersTable → UsersSelectBuilder) AND the generic one, then unions the
--   results, yielding UsersRecord[]|table[] instead of UsersRecord[].
--
--   Solution: 'from' is NOT declared here. types.lua (generated by sleet-cli)
--   augments this class with precise per-table overloads.
--   Before running `sleet generate`, 'from' will show as unknown — that is
--   expected; run the CLI first to enable the full type inference chain.

---@class SleetPreSelectBuilder
---@field where     fun(cond: table): SleetPreSelectBuilder
---@field limit     fun(n: integer): SleetPreSelectBuilder
---@field offset    fun(n: integer): SleetPreSelectBuilder
---@field orderBy   fun(col: ColumnDef, dir?: string): SleetPreSelectBuilder
---@field groupBy   fun(col: ColumnDef): SleetPreSelectBuilder
---@field leftJoin  fun(tbl: table, on: table): SleetPreSelectBuilder
---@field innerJoin fun(tbl: table, on: table): SleetPreSelectBuilder
---@field rightJoin fun(tbl: table, on: table): SleetPreSelectBuilder
---@field execute   fun(): table[]
---@field toSQL     fun(): string, table

---@class SleetInsertBuilder
---@field values  fun(data: table): SleetInsertBuilder
---@field execute fun(): integer
---@field toSQL   fun(): string, table

---@class SleetUpdateBuilder
---@field set     fun(data: table): SleetUpdateBuilder
---@field where   fun(cond: table): SleetUpdateBuilder
---@field execute fun(): integer
---@field toSQL   fun(): string, table

---@class SleetDeleteBuilder
---@field where   fun(cond: table): SleetDeleteBuilder
---@field execute fun(): integer
---@field toSQL   fun(): string, table

-- ─────────────────────────────────────────────────────────────
-- SleetDB — return value of sl.connect()
-- select() returns SleetPreSelectBuilder so that .from(s.users)
-- can infer the record type via the fun<R> field.
-- ─────────────────────────────────────────────────────────────

---@class SleetDB
---@field select fun(cols?: ColumnDef[]): SleetPreSelectBuilder
---@field insert fun(tbl: table): SleetInsertBuilder
---@field update fun(tbl: table): SleetUpdateBuilder
---@field delete fun(tbl: table): SleetDeleteBuilder

-- ─────────────────────────────────────────────────────────────
-- Sleet — Global object (injected into _G.Sleet by @sleet/sleet.lua)
-- ─────────────────────────────────────────────────────────────

---@class Sleet
---
--- Database connection, returns query builder
---@field connect fun(): SleetDB
---
--- Column type constructors — return ColumnDef<T> where T is the Lua value type
---@field serial     fun(): ColumnDef<integer>
---@field bigserial  fun(): ColumnDef<integer>
---@field int        fun(): ColumnDef<integer>
---@field bigint     fun(): ColumnDef<integer>
---@field smallint   fun(): ColumnDef<integer>
---@field tinyint    fun(): ColumnDef<integer>
---@field float      fun(): ColumnDef<number>
---@field double     fun(): ColumnDef<number>
---@field decimal    fun(precision?: integer, scale?: integer): ColumnDef<number>
---@field varchar    fun(len?: integer): ColumnDef<string>
---@field char       fun(len?: integer): ColumnDef<string>
---@field text       fun(): ColumnDef<string>
---@field mediumtext fun(): ColumnDef<string>
---@field longtext   fun(): ColumnDef<string>
---@field boolean    fun(): ColumnDef<boolean>
---@field timestamp  fun(): ColumnDef<string>
---@field datetime   fun(): ColumnDef<string>
---@field date       fun(): ColumnDef<string>
---@field json       fun(): ColumnDef<table>
---
--- Raw SQL fragment (escape hatch)
---@field sql fun(fragment: string, params?: table): table
---
--- WHERE conditions operators
---@field eq        fun(col: ColumnDef, val: any): table
---@field ne        fun(col: ColumnDef, val: any): table
---@field gt        fun(col: ColumnDef, val: any): table
---@field gte       fun(col: ColumnDef, val: any): table
---@field lt        fun(col: ColumnDef, val: any): table
---@field lte       fun(col: ColumnDef, val: any): table
---@field like      fun(col: ColumnDef, val: string): table
---@field ilike     fun(col: ColumnDef, val: string): table
---@field notLike   fun(col: ColumnDef, val: string): table
---@field isNull    fun(col: ColumnDef): table
---@field isNotNull fun(col: ColumnDef): table
---@field inArray   fun(col: ColumnDef, vals: table): table
---@field notInArray fun(col: ColumnDef, vals: table): table
---@field between   fun(col: ColumnDef, a: any, b: any): table
---@field and_      fun(...): table
---@field or_       fun(...): table
---@field not_      fun(cond: table): table

---@type Sleet
Sleet = nil

-- Warning: Generic type declaration must be separate from the function declaration.
-- Fallback for when sleet generate has not been run yet — returns the columns
-- table as-is via @generic.  Once types.lua is generated, specific @overloads
-- for each table name take priority over this generic fallback.
---@generic T: table
---@param name string
---@param columns T
---@return T
---@diagnostic disable-next-line: inject-field
function Sleet.table(name, columns) end
